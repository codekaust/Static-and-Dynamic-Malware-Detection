#!/usr/bin/env python
# coding: utf-8

# In[9]:


import re
import statistics


# In[5]:


feat_location = '''location'''.split()

feat_img_dos_header = '''e_magic e_cblp e_cp
e_crlc e_cparhdr e_minalloc
e_maxalloc e_ss e_sp
e_csum e_ip e_cs
e_lfarlc e_ovno 
e_oemid e_oeminfo e_lfanew '''.split()

feat_nt_header = '''Signature'''.split()

feat_img_file_header = '''Machine NumberOfSections TimeDateStamp
PointerToSymbolTable NumberOfSymbols SizeOfOptionalHeader
Characteristics'''.split()

feat_opt_header = '''Magic MajorLinkerVersion
MinorLinkerVersion SizeOfCode SizeOfInitializedData
SizeOfUninitializedData AddressOfEntryPoint BaseOfCode
ImageBase SectionAlignment FileAlignment
MajorOperatingSystemVersion MinorOperatingSystemVersion MajorImageVersion
MinorImageVersion MajorSubsystemVersion MinorSubsystemVersion
Reserved1 SizeOfImage SizeOfHeaders
CheckSum Subsystem DllCharacteristics
SizeOfStackReserve SizeOfStackCommit SizeOfHeapReserve
SizeOfHeapCommit LoaderFlags NumberOfRvaAndSizes'''.split()

feat_pe_sections = '''SectionsMeanEntropy SectionsMinEntropy SectionsMaxEntropy
SectionsMeanRawsize SectionsMinRawsize SectionMaxRawsize
SectionsMeanVirtualsize SectionsMinVirtualsize SectionMaxVirtualsize
'''.split()

feat_directories = '''
IMAGE_DIRECTORY_ENTRY_EXPORT__VirtualAddress
IMAGE_DIRECTORY_ENTRY_EXPORT__Size
IMAGE_DIRECTORY_ENTRY_IMPORT__VirtualAddress
IMAGE_DIRECTORY_ENTRY_IMPORT__Size
IMAGE_DIRECTORY_ENTRY_RESOURCE__VirtualAddress
IMAGE_DIRECTORY_ENTRY_RESOURCE__Size
IMAGE_DIRECTORY_ENTRY_EXCEPTION__VirtualAddress
IMAGE_DIRECTORY_ENTRY_EXCEPTION__Size
IMAGE_DIRECTORY_ENTRY_SECURITY__VirtualAddress
IMAGE_DIRECTORY_ENTRY_SECURITY__Size
IMAGE_DIRECTORY_ENTRY_BASERELOC__VirtualAddress
IMAGE_DIRECTORY_ENTRY_BASERELOC__Size
IMAGE_DIRECTORY_ENTRY_DEBUG__VirtualAddress
IMAGE_DIRECTORY_ENTRY_DEBUG__Size
IMAGE_DIRECTORY_ENTRY_COPYRIGHT__VirtualAddress
IMAGE_DIRECTORY_ENTRY_COPYRIGHT__Size
IMAGE_DIRECTORY_ENTRY_GLOBALPTR__VirtualAddress
IMAGE_DIRECTORY_ENTRY_GLOBALPTR__Size
IMAGE_DIRECTORY_ENTRY_TLS__VirtualAddress
IMAGE_DIRECTORY_ENTRY_TLS__Size
IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG__VirtualAddress
IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG__Size
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT__VirtualAddress
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT__Size
IMAGE_DIRECTORY_ENTRY_IAT__VirtualAddress
IMAGE_DIRECTORY_ENTRY_IAT__Size
IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT__VirtualAddress
IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT__Size
IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR__VirtualAddress
IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR__Size
IMAGE_DIRECTORY_ENTRY_RESERVED__VirtualAddress
IMAGE_DIRECTORY_ENTRY_RESERVED__Size
'''.split()

feat_dll_list_important = '''
advapi32.dll
shell32.dll
gdi32.dll
ole32.dll
oleaut32.dll
comctl32.dll
version.dll
shlwapi.dll
crypt32.dll
comdlg32.dll
secur32.dll
wininet.dll
oleacc.dll
winmm.dll
setupapi.dll
oledlg.dll
msimg32.dll
gdiplus.dll
cryptui.dll
wintrust.dll
rpcrt4.dll
userenv.dll
imm32.dll
uxtheme.dll
winhttp.dll
'''.split()

# all features
FEATURES = feat_location+feat_img_dos_header+feat_nt_header     +feat_img_file_header+feat_opt_header+feat_pe_sections+     feat_directories+feat_dll_list_important


# In[6]:

def get_feat_list():
    return FEATURES


def get_features(hash_, file):
    dic = {}
    
    dic['location'] = hash_
    
    with open(file, 'r' ,encoding='iso-8859-1', errors='replace') as f:
        text = f.read()
        for lib in feat_dll_list_important: 
            dic[lib]=0
        for lib in feat_dll_list_important:
            r = re.findall(lib, text.lower())
            if r:
                dic[lib] = len(r)
        
    with open(file, 'r', encoding='iso-8859-1', errors='replace') as f:
        lines = f.readlines()

        curr_header = ''
        curr_subheader = ''
        
        
        tmp_entropy = []
        tmp_raw_size = []
        tmp_virt_size = []
        
        
        for line in lines:
            line = line.strip()

            if(re.match(r'----------.*----------', line)):
                curr_header = line.strip('----------')
                curr_subheader = ''
            elif(re.match(r'\[.*\]', line)):
                curr_subheader = line[1:len(line)-1]
            else:
                
                if(curr_header == 'DOS_HEADER' or curr_header == 'NT_HEADERS' or curr_header == 'FILE_HEADER' or curr_header == 'OPTIONAL_HEADER'):
                    splits = line.split()
                    if(len(splits)>=4):
                        key = splits[2][0:len(splits[2])-1]
                        
                        if(key in FEATURES):
                            try:
                                val = int(splits[3], 0)
#                                     print(key, val)

#                                 if key in dic.keys():
#                                     print("ERROR: Key "+key+" exists.", file)
                                    
                                dic[key] = val
                            except Exception as e:
                                pass
#                                 print("in DOS HEADER", file, key, splits[3], e)
                            
                            
                            
                elif(curr_header == 'PE Sections'):
                    splits = line.split()
                    if(len(splits)>=4):
                        if(splits[0]=='Entropy:'):
                            try:
                                val = float(splits[1])
                                tmp_entropy.append(val)
                            except:
                                pass
#                                 print("Can't extract entropy", file)
                        elif(splits[2] == 'SizeOfRawData:'):
                            try:
                                val = int(splits[3], 0)
                                tmp_raw_size.append(val)                               
                            except:
                                pass
#                                 print("Can't extract Raw data size", file, splits)
                        elif(splits[2] == 'Misc_VirtualSize:'):
                            try:
                                val = int(splits[3], 0)
                                tmp_virt_size.append(val)                               
                            except:
                                pass
#                                 print("Can't extract virt size", file, splits)
                                
                
                elif(curr_header == 'Directories'):
                    splits = line.split()
                    if(len(splits)>=4):
                        if(splits[2] == 'VirtualAddress:'):
                            try:
                                val = int(splits[3], 0)
                                key = curr_subheader + '__' + splits[2][0:len(splits[2])-1]
                                if(key in FEATURES):
                                    dic[key]=val
                            except:
                                pass
#                                 print("Can't extract VirtualAddress", file, splits)
                        elif(splits[2] == 'Size:'):
                            try:
                                val = int(splits[3], 0)
                                key = curr_subheader + '__' + splits[2][0:len(splits[2])-1]
                                if(key in FEATURES):
                                    dic[key]=val 
                            except:
                                pass
#                                 print("Can't extract Size", file, splits)                    
                
                
                
                
    if len(tmp_entropy) == len(tmp_raw_size) and len(tmp_raw_size) == len(tmp_virt_size) and 'NumberOfSections' in dic.keys() and len(tmp_virt_size) == dic['NumberOfSections']:
#                 SectionsMeanEntropy SectionsMinEntropy SectionsMaxEntropy
#                 SectionsMeanRawsize SectionsMinRawsize SectionMaxRawsize
#                 SectionsMeanVirtualsize SectionsMinVirtualsize SectionMaxVirtualsize

        dic['SectionsMeanEntropy'] = statistics.mean(tmp_entropy)
        dic['SectionsMeanRawsize'] = statistics.mean(tmp_raw_size)
        dic['SectionsMeanVirtualsize'] = statistics.mean(tmp_virt_size)

        dic['SectionsMinEntropy'] = min(tmp_entropy)
        dic['SectionsMinRawsize'] = min(tmp_raw_size)
        dic['SectionsMinVirtualsize'] = min(tmp_virt_size)

        dic['SectionsMaxEntropy'] = max(tmp_entropy)
        dic['SectionMaxRawsize'] = max(tmp_raw_size)
        dic['SectionMaxVirtualsize'] = max(tmp_virt_size)
    else:
        pass
#         print("Error in entropy etc part")
#         print(dic)
#         print(len(tmp_entropy), len(tmp_raw_size), len(tmp_virt_size))
        
    return dic


# In[8]:


def get_stat_f(hash_stat):
    dics = []
    for hash_, file in hash_stat.items():
        dic = get_features(hash_, file)
        
        feature_missing = False
        for feature in FEATURES:
            if not (feature in dic.keys()):
                if feature in feat_directories:
#                     print("FEAT_DIRECTORY FEATURE MISSING: ", file, feature)
                    dic[feature] = 0
                else:
#                     print("FEATURE MISSING: ", file, feature)
                    feature_missing = True

        if not feature_missing:
            dics.append(dic)


#     with open(csv_location, 'w') as csvfile: 
#         writer = csv.DictWriter(csvfile, fieldnames = FEATURES) 
#         writer.writeheader()
#         writer.writerows(dics)
        
    return dics

